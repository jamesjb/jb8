//
// build.rs --- Cargo build script.
//
// Copyright (C) 2016, James Bielman <jamesjb@gmail.com>
// All Rights Reserved.
//
// Released under the "BSD3" license. See the file "LICENSE"
// for details.
//

#![allow(dead_code)]

// TODO: This is going to parse instruction tables from CPU docs
// and generate instruction decoder macros.

use std::env;
use std::fs::File;
use std::io::{BufRead,BufReader,Write};
use std::path::Path;
use std::str::FromStr;

#[derive(Debug)]
struct Insn {
    opcode: u8,
    name: String,
    addr_mode: String,
    cycles: usize,
    bytes: usize,
}

/// Parse a line from the opcodes file into an `Insn`.
fn parse_line(line: &String) -> Insn {
    let mut iter = line.split_whitespace();

    Insn {
        opcode: u8::from_str_radix(iter.next().unwrap(), 16).unwrap(),
        name: String::from(iter.next().unwrap()),
        addr_mode: String::from(iter.next().unwrap()),
        cycles: usize::from_str(iter.next().unwrap()).unwrap_or(0),
        bytes: usize::from_str(iter.next().unwrap()).unwrap_or(0),
    }
}

fn make_decoder(name: &str, spec_file: &str, out_file: &mut File, nest: usize) {
    let mut in_file = BufReader::new(File::open(spec_file).unwrap());
    let mut buf = String::new();

    write!(out_file, r#"macro_rules! {} {{
    ($op:expr, $this:ident) => {{
        match $op {{
"#, name).unwrap();

    while in_file.read_line(&mut buf).unwrap() > 0 {
        let insn = parse_line(&buf);

        write!(out_file, "            ").unwrap();
        write!(out_file, "{:#04x} => {{ ", insn.opcode).unwrap();

        match insn.addr_mode.as_ref() {
            "ILLEGAL" => {
                write!(out_file, "$this.illegal_instruction($op);").unwrap();
            },
            "IMMEDIATE" => {
                let addr_mode = if insn.bytes - nest == 2 { "imm8" } else if insn.bytes - nest == 3 { "imm16" } else { "imm_unknown" };
                write!(out_file, "let ea = $this.{}(); $this.op_{}(ea);", addr_mode, insn.name).unwrap();
            },
            "RELATIVE" => {
                let addr_mode = if insn.bytes - nest == 2 { "pcrel8" } else if insn.bytes - nest == 3 { "pcrel16" } else { "pcrel_unknown" };
                write!(out_file, "let ea = $this.{}(); $this.op_{}(ea);", addr_mode, insn.name).unwrap();
            },
            "INHERENT" => {
                write!(out_file, "$this.op_{}();", insn.name).unwrap();
            },
            x@"DIRECT" | x@"INDEXED" | x@"EXTENDED" => {
                write!(out_file, "let ea = $this.{}(); $this.op_{}(ea);",
                       x.to_lowercase(), insn.name).unwrap();
            },
            "VARIANT" => {
                write!(out_file, "let subop = $this.fetchb(); {}_decode!(subop, $this);", insn.name.to_lowercase()).unwrap();
            },
            x => {
                write!(out_file, "/* {} */", x).unwrap();
            },
        }

        write!(out_file, " }},\n").unwrap();
        buf.clear();
    }

    write!(out_file,
r#"            _ => unreachable!(),
        }}
    }}
}}

"#).unwrap();
}

fn main() {
    let out_dir = env::var("OUT_DIR").unwrap();
    let dest_path = Path::new(&out_dir).join("cpu_decode.rs");

    let mut f = File::create(&dest_path).unwrap();
    f.write_all(b"// Automatically generated by build.rs\n\n").unwrap();

    make_decoder("cpu_decode", "data/cpu-opcodes.txt", &mut f, 0);
    make_decoder("page1_decode", "data/page1-opcodes.txt", &mut f, 1);
    make_decoder("page2_decode", "data/page2-opcodes.txt", &mut f, 1);
}
